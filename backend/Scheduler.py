from models.Course import Course, Section
from models.Instructor import Instructor
from models.Room import Room
from models.Period import Period

class Scheduler:
    """Generates and schedules sections.

    Intended to be generated by Schedule object. Uses database information to generate and schedule sections. 

    Atrributes:
        courses_and_enrollment: Tuple Array (Course ID, Max_Enrollment, Fulfillment);
        Keeps track of course enrollment numbers and whether there needs to be more sections.

        room_availability: Tuple Array (Period ID, [Room IDs]); 
        Keeps track of which rooms are available at what time.

        room_occupancy: Tuple Array (Room ID, Max Occupancy);
        Keeps track of the max occupancy of the room.

        instructor_availability: Tuple Array (Instructor ID, section count, [Period IDs]);
        Keeps track of the times when the instructor is available.

        course_preferences: Tuple Array (Course ID, [Instructor IDs])
        Keeps track of which instructors prefer a class. Is reinitialized for each section to be assigned.

        instructors_with_no_preferences: Array (Instructor IDs)
        Keeps track of instructors who have no course preferences or have fulfilled their all their preferences. Is reinitialized for each section to be assigned. 

        sections_to_be_assigned: Array (Section ORM Object) of newly generated sections
        Keeps track of sections that need to be assigned in each main control loop

        all_sections: Array (Section ORM Object) all sections that have been generated by this class.
        Keeps track of sections generated by scheduler - will be sent to Schedule parent object.

        courses: Array of courses (Course ORM Object)
        Courses that are being scheduled

        section_counter: counts sections
        counts sections. Used for debugging 

        instructors_with_no_preferences_pos: moves around in instructors_with_no_preferences array to select which instructor
        Used to fairly distribute which instructor is assigned a section no instructor has a preference for.


    """

    # ----- Tuple Arrays ------
    courses_and_enrollment = []
    room_availability = []
    room_occupancy = []
    instructor_availability = []
    course_preferences = []

    # ----- Arrays ------
    instructors_with_no_preferences = []
    sections_to_be_assigned = []
    all_sections = []
    
    # ----- Other Attributes ------
    section_counter = 0
    instructors_with_no_preferences_pos = 0


    def __init__(self, input_courses=[]):
        """ Initialize object

        Args:
            input_courses: defaults to empty - most be Course object array - will make schedule with these courses.
        """
        self.initialize(input_courses)

    def initialize(self, input_courses=[]):
        """ Actually initializes object. Performs queries necessary for scheduling.

        Wrapped by __init__. Fills all tuple arrays based on the input courses list.

        Args:
            input_courses: defaults to empty - most be Course object array - will make schedule with these courses.

        """
        if not input_courses:
            self.courses = Course.query.all()
        else:
            self.courses = input_courses

        self.getCoursesAndEnrollment(self.courses)
        self.getRoomsAndAvailability()
        self.getRoomsAndOccupancy()
        self.getInstructorAvailability()
        self.getCoursePreferences(self.courses)

    def clear(self):
        """Clear function for Scheduler
        
        Empties and reinitializes scheduler. CANNOT be used if select course_input is needed.
        
        """

        self.courses_and_enrollment = []
        self.room_availability = []
        self.room_occupancy = []
        self.instructor_availability = []
        self.course_preferences = []

        self.instructors_with_no_preferences = []
        self.sections_to_be_assigned = []
        self.all_sections = []
        
        self.section_counter = 0
        self.instructors_with_no_preferences_pos = 0

        self.initialize()
        
    def getCoursesAndEnrollment(self, courses):
        """Initalizes courses_and_enrollment tuple array

        Initializes courses_and_enrollment tuple array with course (from courses arg), max_enrollment, and fulfilment value (Starts at 0).

        Args:
            courses: Array of Course ORM Objects
        """
        self.courses_and_enrollment = []
        # Creating a tuple to represent course, max enrollment, and fulfilled/not fulfilled
        for course in courses:
                pull_course = course.id
                tuple_item = (pull_course, course.max_enrollment, 0)
                self.courses_and_enrollment.append(tuple_item)
    
    def getRoomsAndAvailability(self):
        """Initalizes room_availability tuple array

        Initalizes room_availability tuple array with the period ID, and each Room ID (ie. Period ID, [Room ID, Room ID, Room ID, ...])
        """
        self.room_availability = []
        # Creating a tuple to represent room and availabily
        periods = Period.query.all()
        rooms = Room.query.all()
        for period in periods:
            pull_period = period.id

            # All rooms inserted into availability array
            room_ids = [room.id for room in rooms]
            tuple_item = (pull_period, room_ids)
            self.room_availability.append(tuple_item)
    
    def getRoomsAndOccupancy(self):
        """Initalizes room_and_occupancy tuple array

        Initalizes room_and_occupancy tuple array with Room ID and Room max_occupancy (from database).
        """
        self.room_occupancy = []
        # Creating a tuple of all the rooms and occupancy
        rooms = Room.query.all()
        for room in rooms:
            pull_room = room.id
            pull_room_occupancy = room.max_occupancy
            tuple_item = (pull_room, pull_room_occupancy)
            self.room_occupancy.append(tuple_item)
    
    def getInstructorAvailability(self):
        """Initalizes instructor_availability tuple array

        Initalizes instructor availability tuple array with instructor id, the max number of sections an instructor can be assigned, and array of periods. (ie. Instructor ID, 3, [Period ID, Period_ID, ...])
        """
        self.instructor_availability = []
        # Creating a Tuple with instructor id and period ids
        instructors = Instructor.query.all()
        periods = Period.query.all()
        for instructor in instructors:
            pull_insturctor = instructor.id
            period_ids = [period.id for period in periods]
            tuple_item = (pull_insturctor, 4, period_ids)
            self.instructor_availability.append(tuple_item)

    def getInstructorSectionCount(self, instructor_id):
        """Gets instructor section count from instructor_availability array

        Used to initialize instructors_with_no_preference array.

        Args:
            instructor_id: ID of an instructor that is in instructor_availability. 

        Returns: 
            integer representing the number of sections remaining for an instructor or None
        """
        for instructor in self.instructor_availability:
            if instructor[0] == instructor_id:
                return instructor[1]
        return None
    
    def getInstructorsWithNoPref(self, course_id):
        """Initializes instructors_with_no_preferences based on instructor eligibility for a particular course

        An instructor will be added to instructors_with_no_preferences if they do not have a preference for the course, and have not reached their cap on section counts. Runs for each section to be assigned.

        Args:
            course_id: course that the instructors have no preference for.
        """
        self.instructors_with_no_preferences = []

        # Just an array of instructors with no preferences - sorted by priority
        instructors = Instructor.query.order_by(Instructor.priority).all()

        for instructor in instructors:
            if self.checkInstructorEligibility(instructor.id, course_id):
                self.instructors_with_no_preferences.append(instructor.id)

        # If size of instrutcors with no_preferences has been changed, readjust instructors_with_no_preference_pos to keep round robin going
        if self.instructors_with_no_preferences_pos > len(self.instructors_with_no_preferences):
            self.instructors_with_no_preferences_pos = 0

    def checkInstructorEligibility(self, instructor_id, course_id):
        instructor_remaining_section_count = self.getInstructorSectionCount(instructor_id)
        if (self.hasUnfulfilledCoursePreference(instructor_id, course_id) == False) and (instructor_remaining_section_count >= 1):
            return True
        else:
            return False

    def getCoursePreferences(self, courses):
        """Initializes course_preferences tuple array.

        Args:
            courses: list of Course ORM Objects to be used to create tuple 
        """
        for course in courses:
            course_id = course.id
            # get all course preference objects related to course in a list
            course_preferences = course.preferences

            # Empty array to update course preferences in
            sorted_array = []
            for course_pref in course_preferences:
                # Get instructor id
                instructor = course_pref.instructor_id

                # get priority of the instructor
                priority = course_pref.instructor.priority

                # id and priority together
                id_priority_tuple = (instructor, str(priority))

                # put instructor in appropriate place (sorted by priority)
                self.sortedInsert(sorted_array, id_priority_tuple)
            tuple_item = (course_id, sorted_array)
            self.course_preferences.append(tuple_item)

    def getAllSections(self):
        """Creates all_sections by querying database

        You may experience issues with this if there are multiple schedulers created.
        """

        self.all_sections = Section.query.all()

    # Update Functions -----

    def updateCourseEnrollmentGivenRoom(self, course_id, room):
        """Updates course_and_enrollment tuple array attribute after a course has been assigned to a room.

        Course enrollment numbers in the courses_and_enrollment tuple needs to be updated after a section is assigned a room. This function does that.

        Args:
            course_id: Course ID of the course being updated.
            room: Room ORM Object that the section has been assigned to.
        """
        room_occupancy = room.max_occupancy
        for course in self.courses_and_enrollment:

            # course[0] = course_id in in courses_and_enrollment; course[1] = course max enrollment number
            if course[0] == course_id:
                # Subtract room_occupancy from enrollment
                new_occupancy = course[1] - room_occupancy

                if new_occupancy <= 0:
                    fulfilled = 1
                else:
                    fulfilled = 0

                updated_course = (course[0], new_occupancy, fulfilled)
                index = self.courses_and_enrollment.index(course)
                self.courses_and_enrollment[index] = updated_course
                return
            
    def updateCourseEnrollment(self, course_id):
        """Updates courses_and_enrollment when there has been no room assigned.

        Course enrollment numbers in the courses_and_enrollment tuple still needs to be updated after a section is assigned no room. This function does that.

        Args:
            course_id: course whose enrollment needs updating
        """
        for course in self.courses_and_enrollment:
            # course[0] = course_id in in courses_and_enrollment; course[1] = course max enrollment number
            if course[0] == course_id:
                # Subtract room_occupancy from enrollment
                new_occupancy = course[1] - 50

                if new_occupancy <= 0:
                    fulfilled = 1
                else:
                    fulfilled = 0

                updated_course = (course[0], new_occupancy, fulfilled)
                index = self.courses_and_enrollment.index(course)
                self.courses_and_enrollment[index] = updated_course
                return
        
    def updateInstructorAvailability(self, period_id, instructor_id):
        """Updates instructor_availability

        Used after an instructor is assigned to a section. updates the instructor_availability to remove period from the instructor's available periods.
        
        Args:
            period_id: id of the period that needs to be removed from instructor's availability
            instructor_id: id of the instructor whose availability is being updated
        """
        for instructor in self.instructor_availability:
            if instructor[0] == instructor_id:
                availability_array = instructor[2]
                if period_id in availability_array:
                    # the instructor tuple idexed
                    index = self.instructor_availability.index(instructor)
                    
                    # the period in the availability array indexed
                    period_index = availability_array.index(period_id)
                    del availability_array[period_index]
                    
                    updated_instructor_tuple = (instructor[0], instructor[1] - 1, instructor[2])
                    self.instructor_availability[index] = updated_instructor_tuple
                return  # No need to continue after updating
        # Period ID not found, or room_id not found in the availability array
        print("Period ID or Instructor ID not found.")    
       
    def updateRoomAvailability(self, period_id, room_id):
        """Updates room_availability

        Used after room is assigned to a section. Prevents double booking of rooms.

        Args:
            period_id: ID of the period 
            room_id: the room to be removed from room_availabilty at the given period (period_id)

        """
        for period in self.room_availability:
            #period[0] in room_availability represents period ids
            if period[0] == period_id:
                # period[1] is an array of rooms available at the period_id
                availability_array = period[1]
                if room_id in availability_array:
                    room_index = availability_array.index(room_id)
                    del availability_array[room_index]
            if not period[1]:
                del period
        return 
        
    def updateCoursePreferences(self, course_id, instructor_id):
        """Updates course_preferences tuple to reflect instructors with preferences for a course

        Args:
            course_id: id of the course that has been assigned an instructor
            instructor_id: id of the instructor that has been assigned a course

        """
        for course in self.course_preferences:

            # course[0] is the course id
            if course[0] == course_id:
                # course[1] is a list of instructor ids representing instuctors that have a preference for the course
                instructor_ids = course[1]
                if instructor_id in instructor_ids:
                    instructor_index = instructor_ids.index(instructor_id)
                    del instructor_ids[instructor_index]
                return

        

    # Find Functions ----
            
    def findRoomAvailability(self, period_id):
        """Helper function fot getting room_id array from room_availability

        Args:
            period_id: id for the period

        Return:
            Array of room ids available at the fiven period
        """
        for period in self.room_availability:
            if period[0] == period_id:
                return period[1]  # Return array of rooms available during period
        return None

    def findInstructorAvailability(self, instructor_id):
        """Helper function fot getting period_id array from instructor_availability

        Args:
            instructor_id: id for the instructor

        Return:
            Array of periods when the instructor is available
        """
        for instructor in self.instructor_availability:
            if instructor[0] == instructor_id:
                return instructor[2]    # return array of periods instructor is available
        return []
        
    # OTHER
        
    def prepareForMoreSections(self):
        """Prepares the scheduler to create sections for courses that need more.

        Runs before every "main" loop.

        """
        self.sections_to_be_assigned = []
        self.section_counter += 1
        self.instructors_with_no_preferences_pos = 0
        return
        
    def isCourseFulfilled(self):
        """Checks for the "fulfillment" of a course - denoted as a bool in the courses_and_enrollment tuple.

        Fufillment = Sum of section room assignments' max capacity exceeds the max enrollment for the course.

        Returns:
            True or false
        
        """
        for course in self.courses_and_enrollment:
            fulfilled = course[2]
            print(course[0])
            if fulfilled == 0:
                return False
        return True
    
    def createNewSectionsToBeAssigned(self):
        """Creates section list of sections_to_be_assigned. Will only generate a new section if the course is labeled as unfulfilled in courses_and_enrollment
        """
        for course in self.courses_and_enrollment:
            # if course enrollement is unfulfilled, add section to list of sections_to_be_assigned
            if course[2] == 0:
                new_section = Course.newSectionFromId(course[0])
                print(new_section)
                self.sections_to_be_assigned.append(new_section)
    
    def getNextAvailableInstructor(self):
        """Gets next available instructor from instructors_with_no_preferences. Gives a sorta "round robin" distribution effect when selecting the next instructor.

        An instructor is available if it has no preferences, fulfilled all their preferences already, and has not reached the 4 class limit. 

        Return:
            Instructor ORM object representing an instructor that is eligible to teach.

        """
        self.instructors_with_no_preferences_pos = (self.instructors_with_no_preferences_pos + 1) % len(self.instructors_with_no_preferences)
        available_instructor = self.instructors_with_no_preferences[self.instructors_with_no_preferences_pos]
        
        return available_instructor
    
    def createSortedAvailability(self, period_preferences=None, instructor_id=None):
        """Creates a list of potential periods a section could be taught in.

        If there is an instructor_id passed, the returned list will only include periods the instructor is available. (ie. if an instructor is has already been scheduled for a course at 2, the list will be: 1, 3, 4)
        If there are period_preferences passed as well, the returned list will have the preferred periods at the start. (ie. if the same instructor discussed above has a period preference for 4, the list will be: 4, 1, 3,)
        If there is no instructor passed, the returned list will simply be a list of periods that have at least one room available at that time.

        Args:
            period_preferences: defaulted as None. List of PeriodPreference ORM objects.
            instructor_id: defaulted as None. An instructor

        """
        order_periods = []
        # checks if there is an instructor_id passed
        if instructor_id:
            instructor_availablity = self.findInstructorAvailability(instructor_id)
            # check is period preferences has been passed
            if period_preferences:
                # Add to order_periods period_ids corresponding to the periods that the instructor prefers AND is available during
                for period_pref in period_preferences:
                    period_id = period_pref.period_id
                    if period_id in instructor_availablity:
                        order_periods.append(period_pref.period_id)
                # Add only period ids corresponding to the periods where the instructor is available AND there is at least one room available at that time
                for period in self.room_availability:
                    if ((period[0] not in order_periods) and (period[0] in instructor_availablity)):
                        order_periods.append(period[0])
            else:
                # Add only period ids corresponding to the periods where the instructor is available AND there is at least one room available at that time
                for period in self.room_availability:
                    if (period[0] not in order_periods and (period[0] in instructor_availablity)):
                        order_periods.append(period[0])
        else:
            # Add only period ids where there is at least one room available at that period
            for period in self.room_availability:
                if (period[0] not in order_periods):
                    order_periods.append(period[0])
        return order_periods
    
    def getInstructorsWithCoursePref(self, course_id):
        """Gets a list of instructors with a course preference for a particular course, course_id.

        Course preferences are represented in the course_preferences tuple.

        Args:
            course_id: id representing a course in the database

        Return:
            List of instructor_ids with a preference for the passed course

        """
        for course in self.course_preferences:
            # course[0] is course ids, course[1] is a list of instructors
            if course[0] == course_id:
                return course[1]
        return None

    def sortedInsert(self, lst, id_priority_tuple):
        """ Helper function - sorts a list of instructors by priority. Will likely be reworked
        """
        index = 0
        id, priority = id_priority_tuple
        while index < len(lst) and lst[index][1] < priority:
            index += 1
        lst.insert(index, id_priority_tuple[0])

    def hasUnfulfilledCoursePreference(self, instructor_id, course_id):
        """Checks if an instructor has an UNFULFILLED course preference for a particular course.

        Args:
            instructor_id: ID representing an instructor
            course_id: ID representing a course

        Return:
            True or false - true if the instructor has a unfulfilled preference for the course

        """
        for course in self.course_preferences:
            if course[0] == course_id:
                instructor_ids = course[1]
                if instructor_id in instructor_ids:
                    return True
                else:
                    return False
                
    # ALGO
    
    def scheduleSections(self):
        """Schedules sections in sections_to_be_assigned

        Assign Instructor, Assign Period, Assign Room
        
        """
        for section in self.sections_to_be_assigned:
            # Gather course information
            self.getInstructorsWithNoPref(section.course_id)

            # Assign an Instructor to a section
            self.assignInstructor(section)

            # AT THIS POINT, THE SECTION HAS BEEN ASSIGNED AN INSTRUCTOR and can get instructor by using back reference
            assigned_instructor = section.instructor_id

            # Check if Instructor has any time preferences - Create ordered periods array based on period preferences
            if assigned_instructor:
                period_preferences = section.instructor.period_preferences
                sorted_availability = self.createSortedAvailability(period_preferences, assigned_instructor)
            else:
                sorted_availability = self.createSortedAvailability()
            
            # Instructor has free time - assign section to a period that is available to the instructor
            # If we want less incompletes we do it here TODO
            self.assignPeriod(section, sorted_availability)

            # Assigning room
            self.assignRoom(section)
            section.printInfo
                
        self.getAllSections()

    def assignInstructor(self, section):
        """Chooses and sets (assigns) an instructor to the section passed

        Args:
            section: section ORM object that is being manipulated

        """
        # a list of all preferences for the course
        instructors = self.getInstructorsWithCoursePref(section.course_id)
        if not instructors:
            # There are no professors with a preference for this course
            # Assign section to instructor from instructors who have no preferance or have already met their preference
            if self.instructors_with_no_preferences:
                available_instructor = self.getNextAvailableInstructor()
                section.setInstructorByID(available_instructor)
            else:
                # NO instructors are available
                pass

        else:
            # There exists professor(s) with a preference for this course
            # Assign Instructor from Instructors who do have preference for the specific course - based on priority
            
            # This is what is causing more than four per professor TODO
            for instructor in instructors:
                if self.checkInstructorEligibility(instructor, section.course_id):
                    section.setInstructorByID(instructor)
            
            if section.instructor:
                # Update preferences
                self.updateCoursePreferences(section.course_id, instructor)

    def assignPeriod(self, section, potential_periods):
        """Chooses and sets (assigns) a period from the potential_periods to the section passed

        The 0th index in the potential_periods will always be chosen.

        Args:
            section: section ORM object that is being manipulated
            potential_periods: a list of periods that can be selected from

        """
        if potential_periods:
            period_id = potential_periods[0]
            if section.instructor_id:
                period_id = potential_periods[0]
                section.setPeriodByID(period_id)  
                self.updateInstructorAvailability(period_id, section.instructor_id)
        else:
            # This is not clear
            for period in self.room_availability:
                if (period[0] in potential_periods) and (period[1]):
                    section.setPeriodByID(period[0])
                    break
                    
    def assignRoom(self, section):
        """Chooses and sets (assigns) a room to the section passed

        Args:
            section: section ORM object that is being manipulated
        """
        # get available rooms for period
        available_rooms = self.findRoomAvailability(section.period_id)
        if available_rooms:
            # set room to a room that is available during that period
            section.setRoomByID(available_rooms[0])

            # Update enrollment numbers
            self.updateCourseEnrollmentGivenRoom(section.course_id, section.room)
            self.updateRoomAvailability(section.period_id, available_rooms[0])
        else:
            self.updateCourseEnrollment(section.course_id)
            # This will be an incomplete

    def generateSchedule(self):
        """MAIN LOOP of the scheduler. This function is called to generate a schedule.
        """
        while(1):
            self.prepareForMoreSections()
            # self.print()
            self.createNewSectionsToBeAssigned()
            self.scheduleSections()
            # If all courses are fulfilled - end loop
            if self.isCourseFulfilled() == True:
                self.getAllSections()
                break

    def print(self):
        """Print statement for debugging
        """
        print("Scheduler Debug Information:")
        print("Courses and Enrollment:")
        for course in self.courses_and_enrollment:
            print(f"Course ID: {course[0]}, Enrollment: {course[1]}, Fulfilled: {course[2]}")
        print()

        print("Room Availability:")
        for room in self.room_availability:
            print(f"Period ID: {room[0]}, Available Rooms: {room[1]}")
        print()

        print("Room Occupancy:")
        for room in self.room_occupancy:
            print(f"Room ID: {room[0]}, Max Occupancy: {room[1]}")
        print()

        print("Instructor Availability:")
        for instructor in self.instructor_availability:
            print(f"Instructor ID: {instructor[0]}, Section Count: {instructor[1]}, Available Periods: {instructor[2]}")
        print()

        print("Course Preferences:")
        for course in self.course_preferences:
            print(f"Course ID: {course[0]}, Instructor Preferences: {course[1]}")
        print()

        print("Instructors with No Preferences:")
        print(self.instructors_with_no_preferences)
        print()

        print("Sections to be Assigned:")
        for section in self.sections_to_be_assigned:
            print(f"Section ID: {section.id}, Course ID: {section.course_id}")
        print()

        print("All Sections:")
        for section in self.all_sections:
            print(f"Section ID: {section.id}, Course ID: {section.course_id}, Instructor ID: {section.instructor_id}, Period ID: {section.period_id}, Room ID: {section.room_id}")
        print()
        
